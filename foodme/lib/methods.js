var SIZE_RANGE = 2;

var _findGroups = function(name, datetime, size, timeRange, sizeRange) {
  if (!datetime._isAMomentObject) {
    datetime = moment(datetime, "YYYY-MM-DD HH:mm");
  }
  var start = datetime.clone();
  var end = datetime.clone();
  start.subtract(15, 'minutes');
  end.add(15, 'minutes');
  console.log(start._d, start.unix());
  console.log(datetime._d, datetime.unix());
  console.log(end._d, end.unix());
  if (!timeRange && !sizeRange) {
    return Groups.find({restaurant: name, datetime: datetime.unix(), size: size}).fetch();
  } else if (!timeRange && sizeRange) {
    return Groups.find({$and : [
        {restaurant: name, datetime: datetime.unix()},
        {size: {$gte: size - SIZE_RANGE, $lte: size + SIZE_RANGE}}
      ]
    }).fetch();
  } else if (timeRange && !sizeRange) {
    // this never happens
    return Groups.find({ $and : [
        {restaurant: name, size: size},
        {datetime: {$gte: start.unix(), $lte: end.unix()}}
      ]
    }).fetch();   
  } else {
    return Groups.find({ $and : [
        {restaurant: name},
        {datetime: {$gte: start.unix(), $lte: end.unix()}},
        {size: {$gte: size - SIZE_RANGE, $lte: size + SIZE_RANGE}}
      ]
    }).fetch();
  }
};

Meteor.methods({
  getLocalRestaurants: function(loc) {
    var auth = Accounts.loginServiceConfiguration.findOne({service: 'yelp'});

    var yelp = Meteor.npmRequire("yelp").createClient({
      consumer_key: auth.consumerKey, 
      consumer_secret: auth.consumerSecret,
      token: auth.accessToken,
      token_secret: auth.accessTokenSecret,
    });

    var ll = loc.latitude + "," + loc.longitude;

    var a_search = Async.wrap(yelp, "search");

    var res = a_search({term: "food", ll: ll, limit: 5});
    return res;
  },

  createGM: function(name, people) {
    var GMAPI = Meteor.npmRequire("groupme").Stateless;
    var auth = Accounts.loginServiceConfiguration.findOne({service: "groupme"});
    var a_create = Async.wrap(GMAPI.Groups, "create");

    var res = a_create(auth.key, {name: name, description: "autogenerated GroupMe for FoodMe", share: true});
    return res.share_url;
  },

  findGroups: function(name, datetime, size, timeRange, sizeRange) {
    return _findGroups(name, datetime, size, timeRange, sizeRange);
  },

  groupAdd: function(person, restaurant, sDate, sTime, sSize) {
    var groups, retCode = 0;
    var datetime = moment(sDate + ' ' + sTime, "YYYY-MM-DD HH:mm");
    var size = parseInt(sSize, 10);

    groups = _findGroups(restaurant, datetime, size, false, false);
    // TODO - add Meteor.userId() to the group^ here
    
    if (groups.length == 0) {
      console.log("couldn't find any groups which matched exactlyish");
      retCode = 1;
      groups = _findGroups(restaurant, datetime, size, false, true);
    } else {
      console.log("found a group which matched exactly", groups);
      var group_id = groups[0]._id;
      Groups.update({_id: group_id}, {$addToSet: {people: person}});
      if (Groups.findOne(group_id).people.length == Groups.findOne(group_id).size) {
        Groups.update({_id: group_id}, {$set: {atCapacity: true}});
      }

      return {id: group_id, retCode: retCode}; 
    }

    if (groups.length == 0) {
      console.log("couldn't find any groups with size in the range")
      retCode = 2;
      groups = _findGroups(restaurant, datetime, size, true, true);
    }

    if (groups.length == 0) {
      console.log("couldn't find any groups with datetime or size in range, inserting");
      retCode = 3;

      var id = Groups.insert({
        restaurant: restaurant,
        datetime: datetime.unix(),
        size: size,
        people: [person],
        atCapacity: false
      });
      return {id: id, retCode: retCode};
    }

    var group_id = groups[0]._id;
    return {id: group_id, retCode: retCode};
  }
})
